"""Run JEEDS on Blackhawks shot data to estimate player execution skill.

This module stitches together the Snowflake-backed Blackhawks API with the
framework's JEEDS implementation (``JointMethodQRE``).  The workflow:

1. Pull per-shot metadata for a given player across selected games via
   :func:`BlackhawksAPI.query_player_game_info`.
2. Convert those raw SQL rows into angular heatmaps and covariances expected by
   the JEEDS estimator for the hockey domain.
3. Feed each observed shot into JEEDS and return the final MAP execution-skill
   estimate.

The transformation stage intentionally makes a few lightweight assumptions so it
can run without the heavyweight simulation artifacts generated by the existing
hockey experiments:

* Expected values are derived from the shot's post-shot xG probability and
  smoothed over a (y, z) grid to approximate the reward surface JEEDS normally
  receives from simulation.
* Execution skill values are interpreted as inverse noise levels when building
  covariance matrices; higher skill concentrates probability mass around the
  intended target while lower skill spreads it out.

Example
-------
from BlackhawksSkillEstimation.BlackhawksJEEDS import estimate_player_skill
estimate = estimate_player_skill(player_id=950160, game_ids=[44604, 270247])
print(f"Estimated execution skill: {estimate:.3f}")
"""
from __future__ import annotations

import argparse
import math
from dataclasses import dataclass, field
from pathlib import Path
from typing import Sequence

import numpy as np
from scipy.ndimage import gaussian_filter

from BlackhawksAPI import query_player_game_info
from Environments.Hockey import getAngularHeatmapsPerPlayer as angular_heatmaps
from Estimators.joint import JointMethodQRE


@dataclass
class SimpleHockeySpaces:
    """Minimal space object exposing the hooks JEEDS expects for hockey.

    The production framework builds a rich :class:`SpacesHockey` structure that
    caches precomputed EV surfaces, covariances, and target grids.  For this
    integration we only need a subset of those attributes:

    ``possibleTargets``
        Flattened list of (y, z) candidates used when evaluating shot PDFs.
    ``delta``
        Grid spacing (dy, dz); maintained for parity with the framework API.
    ``allCovs``
        Covariance matrices keyed by ``getKey([x, x], 0.0)``.
    """

    y_grid: np.ndarray
    z_grid: np.ndarray
    candidate_execution_skills: Sequence[float]
    possible_targets: np.ndarray | None = None
    possibleTargets: np.ndarray = field(init=False)

    def __post_init__(self) -> None:
        dy = np.diff(self.y_grid).mean() if len(self.y_grid) > 1 else 1.0
        dz = np.diff(self.z_grid).mean() if len(self.z_grid) > 1 else 1.0
        self.delta = (float(dy), float(dz))

        if self.possible_targets is None:
            self.possibleTargets = np.array(
                [(y, z) for y in self.y_grid for z in self.z_grid], dtype=float
            )
        else:
            self.possibleTargets = np.array(self.possible_targets, dtype=float)

        self.all_covs: dict[str, np.ndarray] = {}
        for skill in self.candidate_execution_skills:
            key = self.get_key([skill, skill], r=0.0)
            self.all_covs[key] = self._covariance_from_skill(skill)

    # TODO: need to verify that this _covariance_from_skill method is what we actually want. The steps for determining
    #   which execution skill levels to test seem convoluted.

    @staticmethod
    def _covariance_from_skill(skill: float) -> np.ndarray:
        variance = 1.0 / max(skill, 1e-6) ** 2
        return np.diag([variance, variance])

    '''
    Examples of how skill translates to variance:
    skill: 0.25; variance: 16.000
    skill: 0.50; variance: 4.000
    skill: 0.75; variance: 1.778
    skill: 1.00; variance: 1.000
    skill: 1.25; variance: 0.640
    skill: 1.50; variance: 0.444
    skill: 1.75; variance: 0.327
    skill: 2.00; variance: 0.250
    '''

    @staticmethod
    def get_key(info: Sequence[float], r: float) -> str:
        return "|".join(map(str, info)) + f"|{r}"


@dataclass
class JEEDSInputs:
    spaces_per_shot: list[SimpleHockeySpaces]
    actions: list[list[float]]
    info_rows: list[dict[str, object]]


def _ev_surface_for_shot(
    probability: float,
    location_y: float,
    location_z: float,
    y_grid: np.ndarray,
    z_grid: np.ndarray,
    base_sigma: float,
) -> np.ndarray:
    yy, zz = np.meshgrid(y_grid, z_grid)
    dist2 = (yy - location_y) ** 2 + (zz - location_z) ** 2
    return probability * np.exp(-dist2 / (2.0 * base_sigma**2))


def transform_shots_for_jeeds(
    df,
    candidate_skills: Sequence[float],
    grid_step: float = 0.25,
    base_sigma: float = 0.5,
) -> JEEDSInputs:
    """Convert SQL rows into the structures JEEDS expects.

    Parameters
    ----------
    df:
        DataFrame returned by :func:`query_player_game_info`.
    candidate_skills:
        Execution-skill hypotheses passed to JEEDS.
    grid_step:
        Deprecated in angular mode; retained for backward compatibility.
    base_sigma:
        Standard deviation for the base Gaussian centered on the observed shot
        location (in the same units as the angular heatmap utilities).
    """

    df = df.rename(columns=str.lower)
    y_grid = angular_heatmaps.Y
    z_grid = angular_heatmaps.Z

    info_rows: list[dict[str, object]] = []
    actions: list[list[float]] = []
    spaces_per_shot: list[SimpleHockeySpaces] = []

    for _, row in df.iterrows():
        base_ev = _ev_surface_for_shot(
            probability=float(row["probability"]),
            location_y=float(row["location_y"]),
            location_z=float(row["location_z"]),
            y_grid=y_grid,
            z_grid=z_grid,
            base_sigma=base_sigma,
        )

        player_location = np.array([float(row["start_x"]), float(row["start_y"])])
        executed_action = np.array([float(row["location_y"]), float(row["location_z"])])

        (
            dirs,
            elevations,
            _,
            grid_targets_angular,
            _,
            _,
            _,
            grid_utilities_computed,
            executed_action_angular,
            skip,
            _,
        ) = angular_heatmaps.getAngularHeatmap(
            base_ev,
            player_location,
            executed_action,
        )

        if skip:
            continue

        spaces = SimpleHockeySpaces(
            np.array(dirs),
            np.array(elevations),
            candidate_skills,
            possible_targets=grid_targets_angular.reshape(-1, 2),
        )

        entry = {"evsPerXskill": {}, "maxEVPerXskill": {}, "focalActions": []}

        for skill in candidate_skills:
            key = spaces.get_key([skill, skill], r=0.0)
            # More skilled shooters keep reward mass near the aimed point; less
            # skilled shooters smear it out.
            sigma = max(base_sigma / max(math.sqrt(skill), 1e-3), 1e-3)
            evs = gaussian_filter(grid_utilities_computed, sigma=sigma)

            entry["evsPerXskill"][key] = evs
            entry["maxEVPerXskill"][key] = float(np.max(evs))

            best_idx = int(np.argmax(evs))
            iy, iz = np.unravel_index(best_idx, (len(dirs), len(elevations)))
            entry["focalActions"].append(
                [float(grid_targets_angular[iy, iz, 0]), float(grid_targets_angular[iy, iz, 1])]
            )

        info_rows.append(entry)
        actions.append([float(executed_action_angular[0]), float(executed_action_angular[1])])
        spaces_per_shot.append(spaces)

    return JEEDSInputs(spaces_per_shot=spaces_per_shot, actions=actions, info_rows=info_rows)


def ensure_results_directories(results_folder: Path) -> None:
    times_dir = results_folder / "times" / "estimators"
    times_dir.mkdir(parents=True, exist_ok=True)


def estimate_player_skill(
    player_id: int,
    game_ids: Sequence[int],
    *,
    candidate_skills: Sequence[float] | None = None,
    num_planning_skills: int = 25,
    grid_step: float = 0.25,
    base_sigma: float = 0.5,
    results_folder: Path | str = Path("blackhawks-jeeds"),
    rng_seed: int | None = 0,
) -> float:
    """Return the JEEDS MAP execution-skill estimate for a player.

    Parameters mirror :func:`transform_shots_for_jeeds` with additional JEEDS
    configuration knobs.  The estimator relies on the standard Blackhawks
    Snowflake environment variables to authenticate when fetching shots.
    """

    candidate_skills = list(candidate_skills or np.linspace(0.25, 2.0, 8))

    df = query_player_game_info(player_id=player_id, game_ids=list(game_ids))
    if df.empty:
        raise RuntimeError("No shot data returned for the requested player/games.")

    jeeds_inputs = transform_shots_for_jeeds(
        df,
        candidate_skills=candidate_skills,
        grid_step=grid_step,
        base_sigma=base_sigma,
    )
    if not jeeds_inputs.actions:
        raise RuntimeError("No usable shot data remained after angular conversion.")

    estimator = JointMethodQRE(list(candidate_skills), num_planning_skills, "hockey-multi")
    results_folder = Path(results_folder)
    ensure_results_directories(results_folder)

    rng = np.random.default_rng(rng_seed)
    tag = f"Player_{player_id}"

    for idx, (spaces, info, action) in enumerate(
        zip(jeeds_inputs.spaces_per_shot, jeeds_inputs.info_rows, jeeds_inputs.actions)
    ):
        estimator.add_observation(
            rng,
            spaces,
            state=None,
            action=action,
            resultsFolder=str(results_folder),
            tag=tag,
            infoPerRow=info,
            s=str(idx),
        )

    results = estimator.get_results()
    map_key = f"{estimator.method_type}-MAP-{estimator.num_execution_skills}-{estimator.num_rationality_levels}-xSkills"
    estimates = results.get(map_key, [])
    if not estimates:
        raise RuntimeError("JEEDS returned no MAP execution-skill estimate.")

    return float(estimates[-1])


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run JEEDS on Blackhawks shots.")
    parser.add_argument("player_id", type=int, help="Hawks player identifier.")
    parser.add_argument(
        "game_ids",
        type=int,
        nargs="+",
        help="One or more game identifiers to include in the estimation run.",
    )
    # TODO: last exited recursive code check here

    parser.add_argument(
        "--candidate-skills",
        type=float,
        nargs="+",
        default=None,
        help="Optional execution-skill grid for JEEDS (defaults to 8 values between 0.25 and 2.0).",
    )

    # TODO: need to make sure that 0.25 up to 2.0 is a reasonable range for the data we are looking at;
    #  will need to check how .25 ... 2 are getting used; not sure whether they're raw rink meters or something else

    parser.add_argument(
        "--num-planning-skills",
        type=int,
        default=25,
        help="Number of planning-skill hypotheses passed to JEEDS.",
    )
    parser.add_argument(
        "--grid-step",
        type=float,
        default=0.25,
        help="Grid spacing (meters) for the reward surface.",
    )
    parser.add_argument(
        "--base-sigma",
        type=float,
        default=0.5,
        help="Base Gaussian sigma (meters) around the observed shot location.",
    )
    parser.add_argument(
        "--results-folder",
        type=Path,
        default=Path("Experiments/blackhawks-jeeds"),
        help="Directory where JEEDS timing hooks can write logs.",
    )
    parser.add_argument(
        "--rng-seed",
        type=int,
        default=0,
        help="Seed for the numpy random generator used during estimation.",
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    estimate = estimate_player_skill(
        player_id=args.player_id,
        game_ids=args.game_ids,
        candidate_skills=args.candidate_skills,
        num_planning_skills=args.num_planning_skills,
        grid_step=args.grid_step,
        base_sigma=args.base_sigma,
        results_folder=args.results_folder,
        rng_seed=args.rng_seed,
    )
    print(f"JEEDS MAP execution skill: {estimate:.3f}")


if __name__ == "__main__":
    main()
