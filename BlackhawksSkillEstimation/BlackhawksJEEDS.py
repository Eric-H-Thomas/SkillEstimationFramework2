"""Run JEEDS on Blackhawks shot data to estimate player execution skill.

This module stitches together the Snowflake-backed Blackhawks API with the
framework's JEEDS implementation (``JointMethodQRE``).  The workflow:

1. Pull per-shot metadata for a given player across selected games via
   :func:`BlackhawksAPI.query_player_game_info`.
2. Convert those raw SQL rows into angular heatmaps and covariances expected by
   the JEEDS estimator for the hockey domain.
3. Feed each observed shot into JEEDS and return the final MAP execution-skill
   estimate.

The transformation stage intentionally makes a few lightweight assumptions so it
can run without the heavyweight simulation artifacts generated by the existing
hockey experiments:

* Expected values are derived from the shot's post-shot xG probability and
  smoothed over a (y, z) grid to approximate the reward surface JEEDS normally
  receives from simulation.
* Execution skill (xskill) is modeled as standard deviation in radians: higher
  xskill spreads probability mass widely (worse execution, high miss rate),
  while lower xskill concentrates mass tightly (better execution, low miss rate).
  This follows the production hockey.py convention where getCovMatrix treats the
  skill parameter as the standard deviation of the Gaussian execution noise.

Example
-------
from BlackhawksSkillEstimation.BlackhawksJEEDS import estimate_player_skill
estimates = estimate_player_skill(player_id=950160, game_ids=[44604, 270247])
print(f"Execution skill: {estimates['execution_skill']:.4f} rad (lower=better)")
print(f"Rationality: {estimates['rationality']:.2f} (higher=better, experimental)")
"""
from __future__ import annotations

import argparse
import math
from dataclasses import dataclass, field
from pathlib import Path
from typing import Sequence

import numpy as np
from scipy.ndimage import gaussian_filter

from BlackhawksAPI import query_player_game_info
from Environments.Hockey import getAngularHeatmapsPerPlayer as angular_heatmaps
from Estimators.joint import JointMethodQRE


@dataclass
class SimpleHockeySpaces:
    """Minimal space object exposing the hooks JEEDS expects for hockey.

    The production framework builds a rich :class:`SpacesHockey` structure that
    caches precomputed EV surfaces, covariances, and target grids.  For this
    integration we only need a subset of those attributes:

    ``possibleTargets``
        Flattened list of (y, z) candidates used when evaluating shot PDFs.
    ``delta``
        Grid spacing (dy, dz); maintained for parity with the framework API.
    ``allCovs``
        Covariance matrices keyed by ``getKey([x, x], 0.0)``.
    """

    y_grid: np.ndarray
    z_grid: np.ndarray
    candidate_execution_skills: Sequence[float]
    possible_targets: np.ndarray | None = None
    possibleTargets: np.ndarray = field(init=False)

    def __post_init__(self) -> None:
        dy = np.diff(self.y_grid).mean() if len(self.y_grid) > 1 else 1.0
        dz = np.diff(self.z_grid).mean() if len(self.z_grid) > 1 else 1.0
        self.delta = (float(dy), float(dz))

        if self.possible_targets is None:
            self.possibleTargets = np.array(
                [(y, z) for y in self.y_grid for z in self.z_grid], dtype=float
            )
        else:
            self.possibleTargets = np.array(self.possible_targets, dtype=float)

        self.all_covs: dict[str, np.ndarray] = {}
        for skill in self.candidate_execution_skills:
            key = self.get_key([skill, skill], r=0.0)
            self.all_covs[key] = self._covariance_from_skill(skill)

    # TODO: need to verify that this _covariance_from_skill method is what we actually want. The steps for determining
    #   which execution skill levels to test seem convoluted.

    @staticmethod
    def _covariance_from_skill(skill: float) -> np.ndarray:
        """Return a 2D diagonal covariance matrix for execution error in angular space.
        
        The input skill is the standard deviation (in radians) of execution error
        in both direction and elevation. Variance = skill², so:
        - Higher skill → larger variance → worse execution (looser spread)
        - Lower skill → smaller variance → better execution (tighter cluster)
        """
        variance = max(skill, 1e-6) ** 2
        return np.diag([variance, variance])

    '''
    Examples of how skill (in radians) translates to variance:
    skill: 0.004; variance: 0.000016 (elite execution, tight cluster)
    skill: 0.02;  variance: 0.0004   (strong execution, tight spread)
    skill: 0.1;   variance: 0.01     (moderate execution)
    skill: 0.3;   variance: 0.09     (loose execution, wide spread)
    skill: 0.6;   variance: 0.36     (poor execution, very wide spread)
    skill: 0.785 (π/4); variance: 0.616 (terrible execution, nearly random)
    '''

    @staticmethod
    def get_key(info: Sequence[float], r: float) -> str:
        return "|".join(map(str, info)) + f"|{r}"


@dataclass
class JEEDSInputs:
    spaces_per_shot: list[SimpleHockeySpaces]
    actions: list[list[float]]
    info_rows: list[dict[str, object]]


# ============================================================================
# ARCHITECTURAL NOTE: Spaces as Reward Maps/Reward Surfaces
# ============================================================================
#
# A "Space" in this framework is a REWARD MAP—a lookup table that tells the
# estimator: "For this shot location, here are the possible aims and how
# valuable each one is."
#
# **SpacesHockey (production framework):**
#   - Pre-computes reward surfaces for EVERY POSSIBLE SHOT LOCATION
#   - Uses expensive scipy.signal.convolve2d operations with skill-based kernels
#   - Stores all results in memory or on disk
#   - Reuses the same Space object across many shots in an experiment
#   - Used by: Estimators when processing simulation data
#
# **SimpleHockeySpaces (this module):**
#   - Computes reward surface for ONLY ONE SHOT AT A TIME
#   - Uses _ev_surface_for_shot() to create a minimal Gaussian spike at the
#     observed ball location, scaled by post-shot xG probability
#   - Creates a new Space instance per shot, discards it after use
#   - No expensive precomputation needed
#   - Used by: BlackhawksJEEDS when processing real player data from Snowflake
#
# Both expose the same interface (possibleTargets, all_covs, delta, get_key())
# so JointMethodQRE treats them identically during skill estimation.


def _ev_surface_for_shot(
    probability: float,
    location_y: float,
    location_z: float,
    y_grid: np.ndarray,
    z_grid: np.ndarray,
    base_sigma: float,
) -> np.ndarray:
    yy, zz = np.meshgrid(y_grid, z_grid)
    dist2 = (yy - location_y) ** 2 + (zz - location_z) ** 2
    return probability * np.exp(-dist2 / (2.0 * base_sigma**2))


def transform_shots_for_jeeds(
    df,
    candidate_skills: Sequence[float],
    grid_step: float = 0.25,
    base_sigma: float = 0.5,
) -> JEEDSInputs:
    """Convert SQL rows into the structures JEEDS expects.

    Parameters
    ----------
    df:
        DataFrame returned by :func:`query_player_game_info`.
    candidate_skills:
        Execution-skill hypotheses passed to JEEDS.
    grid_step:
        Deprecated in angular mode; retained for backward compatibility.
    base_sigma:
        Standard deviation for the base Gaussian centered on the observed shot
        location (in the same units as the angular heatmap utilities).
    """

    df = df.rename(columns=str.lower)
    y_grid = angular_heatmaps.Y
    z_grid = angular_heatmaps.Z

    info_rows: list[dict[str, object]] = []
    actions: list[list[float]] = []
    spaces_per_shot: list[SimpleHockeySpaces] = []

    for _, row in df.iterrows():
        base_ev = _ev_surface_for_shot(
            probability=float(row["probability"]),
            location_y=float(row["location_y"]),
            location_z=float(row["location_z"]),
            y_grid=y_grid,
            z_grid=z_grid,
            base_sigma=base_sigma,
        )

        player_location = np.array([float(row["start_x"]), float(row["start_y"])])
        executed_action = np.array([float(row["location_y"]), float(row["location_z"])])

        (
            dirs,
            elevations,
            _,
            grid_targets_angular,
            _,
            _,
            _,
            grid_utilities_computed,
            executed_action_angular,
            skip,
            _,
        ) = angular_heatmaps.getAngularHeatmap(
            base_ev,
            player_location,
            executed_action,
        )

        if skip:
            continue

        spaces = SimpleHockeySpaces(
            np.array(dirs),
            np.array(elevations),
            candidate_skills,
            possible_targets=grid_targets_angular.reshape(-1, 2),
        )

        entry = {"evsPerXskill": {}, "maxEVPerXskill": {}, "focalActions": []}

        # Compute skill-dependent EV surface smoothing.
        # Lower xskill (tight execution) → sharp EV surface (player hits what they aim at)
        # Higher xskill (loose execution) → blurred EV surface (expected value smears across potential hit locations)
        dir_bin_size = (dirs[-1] - dirs[0]) / (len(dirs) - 1) if len(dirs) > 1 else 0.01
        elev_bin_size = (elevations[-1] - elevations[0]) / (len(elevations) - 1) if len(elevations) > 1 else 0.01
        avg_bin_size = (dir_bin_size + elev_bin_size) / 2

        for skill in candidate_skills:
            key = spaces.get_key([skill, skill], r=0.0)
            # sigma in grid bins: skill (rad) / avg_bin_size (rad/bin) = bins
            # Clamp to avoid extreme smoothing or no smoothing.
            sigma = max(min(skill / avg_bin_size, 1.0), 1e-3)
            evs = gaussian_filter(grid_utilities_computed, sigma=sigma)

            entry["evsPerXskill"][key] = evs
            entry["maxEVPerXskill"][key] = float(np.max(evs))

            best_idx = int(np.argmax(evs))
            iy, iz = np.unravel_index(best_idx, (len(dirs), len(elevations)))
            entry["focalActions"].append(
                [float(grid_targets_angular[iy, iz, 0]), float(grid_targets_angular[iy, iz, 1])]
            )

        info_rows.append(entry)
        actions.append([float(executed_action_angular[0]), float(executed_action_angular[1])])
        spaces_per_shot.append(spaces)

    return JEEDSInputs(spaces_per_shot=spaces_per_shot, actions=actions, info_rows=info_rows)


def ensure_results_directories(results_folder: Path) -> None:
    times_dir = results_folder / "times" / "estimators"
    times_dir.mkdir(parents=True, exist_ok=True)


def estimate_player_skill(
    player_id: int,
    game_ids: Sequence[int],
    *,
    candidate_skills: Sequence[float] | None = None,
    num_planning_skills: int = 25,
    grid_step: float = 0.25,
    base_sigma: float = 0.5,
    results_folder: Path | str = Path("blackhawks-jeeds"),
    rng_seed: int | None = 0,
) -> dict[str, float]:
    """Return JEEDS MAP estimates of execution skill and rationality for a player.

    Parameters mirror :func:`transform_shots_for_jeeds` with additional JEEDS
    configuration knobs.  The estimator relies on the standard Blackhawks
    Snowflake environment variables to authenticate when fetching shots.

    Returns
    -------
    dict
        Dictionary with keys:
        - 'execution_skill': MAP estimate of xskill in radians.
          **Lower is better** (tight execution). Range: [0.004, π/4].
        - 'rationality': MAP estimate of decision-making optimality.
          **Higher is better** (optimal aim selection).
          **EXPERIMENTAL**: May not fully account for game context (defenders, time pressure).
    """

    # Default to 10 execution skill hypotheses spanning practical angular range (radians).
    # 0.004 rad ≈ 0.23°, 0.785 rad = π/4 ≈ 45°
    # These are the same numbers used in getAngularHeatMapsPerPlayer.py under line 217.
    candidate_skills = list(candidate_skills or np.linspace(0.004, np.pi / 4, 10))

    df = query_player_game_info(player_id=player_id, game_ids=list(game_ids))
    if df.empty:
        raise RuntimeError("No shot data returned for the requested player/games.")

    jeeds_inputs = transform_shots_for_jeeds(
        df,
        candidate_skills=candidate_skills,
        grid_step=grid_step,
        base_sigma=base_sigma,
    )
    if not jeeds_inputs.actions:
        raise RuntimeError("No usable shot data remained after angular conversion.")

    estimator = JointMethodQRE(list(candidate_skills), num_planning_skills, "hockey-multi")
    results_folder = Path(results_folder)
    ensure_results_directories(results_folder)

    rng = np.random.default_rng(rng_seed)
    tag = f"Player_{player_id}"

    for idx, (spaces, info, action) in enumerate(
        zip(jeeds_inputs.spaces_per_shot, jeeds_inputs.info_rows, jeeds_inputs.actions)
    ):
        estimator.add_observation(
            rng,
            spaces,
            state=None,
            action=action,
            resultsFolder=str(results_folder),
            tag=tag,
            infoPerRow=info,
            s=str(idx),
        )

    results = estimator.get_results()
    
    # Extract MAP estimates for both execution skill and rationality
    xskill_key = f"{estimator.method_type}-MAP-{estimator.num_execution_skills}-{estimator.num_rationality_levels}-xSkills"
    pskill_key = f"{estimator.method_type}-MAP-{estimator.num_execution_skills}-{estimator.num_rationality_levels}-pSkills"
    
    xskill_estimates = results.get(xskill_key, [])
    pskill_estimates = results.get(pskill_key, [])
    
    if not xskill_estimates:
        raise RuntimeError("JEEDS returned no MAP execution-skill estimate.")
    if not pskill_estimates:
        raise RuntimeError("JEEDS returned no MAP rationality estimate.")

    return {
        "execution_skill": float(xskill_estimates[-1]),
        "rationality": float(pskill_estimates[-1]),
    }


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run JEEDS on Blackhawks shots.")
    parser.add_argument("player_id", type=int, help="Hawks player identifier.")
    parser.add_argument(
        "game_ids",
        type=int,
        nargs="+",
        help="One or more game identifiers to include in the estimation run.",
    )
    # TODO: last exited recursive code check here

    parser.add_argument(
        "--candidate-skills",
        type=float,
        nargs="+",
        default=None,
        help="Optional execution-skill grid for JEEDS in radians (defaults to 10 values between 0.004 and π/4).",
    )

    # Fixed: skill is in radians. Range [0.004, π/4] ≈ [0.004, 0.785] rad spans from minimal to major execution variance.
    #        This matches production hockey.py domain convention where getCovMatrix uses skill stdDev.

    parser.add_argument(
        "--num-planning-skills",
        type=int,
        default=25,
        help="Number of planning-skill hypotheses passed to JEEDS.",
    )
    parser.add_argument(
        "--grid-step",
        type=float,
        default=0.25,
        help="Grid spacing (meters) for the reward surface.",
    )
    parser.add_argument(
        "--base-sigma",
        type=float,
        default=0.5,
        help="Base Gaussian sigma (meters) around the observed shot location.",
    )
    parser.add_argument(
        "--results-folder",
        type=Path,
        default=Path("Experiments/blackhawks-jeeds"),
        help="Directory where JEEDS timing hooks can write logs.",
    )
    parser.add_argument(
        "--rng-seed",
        type=int,
        default=0,
        help="Seed for the numpy random generator used during estimation.",
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    estimates = estimate_player_skill(
        player_id=args.player_id,
        game_ids=args.game_ids,
        candidate_skills=args.candidate_skills,
        num_planning_skills=args.num_planning_skills,
        grid_step=args.grid_step,
        base_sigma=args.base_sigma,
        results_folder=args.results_folder,
        rng_seed=args.rng_seed,
    )
    print(f"JEEDS MAP execution skill: {estimates['execution_skill']:.4f} rad (lower is better)")
    print(f"JEEDS MAP rationality:     {estimates['rationality']:.2f} (higher is better, EXPERIMENTAL)")


if __name__ == "__main__":
    main()
