"""Run JEEDS on Blackhawks shot data to estimate player execution skill.

This module stitches together the Snowflake-backed Blackhawks API with the
framework's JEEDS implementation (``JointMethodQRE``).  The workflow:

1. Pull per-shot metadata for a given player across selected games via
   :func:`BlackhawksAPI.query_player_game_info`.
2. Convert those raw SQL rows into the grids and covariances expected by the
   JEEDS estimator for the hockey domain.
3. Feed each observed shot into JEEDS and return the final MAP execution-skill
   estimate.

The transformation stage intentionally makes a few lightweight assumptions so it
can run without the heavyweight simulation artifacts generated by the existing
hockey experiments:

* Expected values are derived from the shot's post-shot xG probability and
  smoothed over a (y, z) grid to approximate the reward surface JEEDS normally
  receives from simulation.
* Execution skill values are interpreted as inverse noise levels when building
  covariance matrices; higher skill concentrates probability mass around the
  intended target while lower skill spreads it out.

Example
-------
from BlackhawksSkillEstimation.BlackhawksJEEDS import estimate_player_skill
estimate = estimate_player_skill(player_id=950160, game_ids=[44604, 270247])
print(f"Estimated execution skill: {estimate:.3f}")
"""
from __future__ import annotations

import argparse
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Sequence

import numpy as np
from scipy.ndimage import gaussian_filter

from BlackhawksAPI import query_player_game_info
from Estimators.joint import JointMethodQRE


# TODO: make sure getAngularHeatmapsPerPlayer.py got used properly; this code might be reinventing the wheel


@dataclass
class SimpleHockeySpaces:
    """Minimal space object exposing the hooks JEEDS expects for hockey.

    The production framework builds a rich :class:`SpacesHockey` structure that
    caches precomputed EV surfaces, covariances, and target grids.  For this
    integration we only need a subset of those attributes:

    ``possibleTargets``
        Flattened list of (y, z) candidates used when evaluating shot PDFs.
    ``delta``
        Grid spacing (dy, dz); maintained for parity with the framework API.
    ``allCovs``
        Covariance matrices keyed by ``getKey([x, x], 0.0)``.
    """

    y_grid: np.ndarray
    z_grid: np.ndarray
    candidate_execution_skills: Sequence[float]

    def __post_init__(self) -> None:
        dy = np.diff(self.y_grid).mean() if len(self.y_grid) > 1 else 1.0
        dz = np.diff(self.z_grid).mean() if len(self.z_grid) > 1 else 1.0
        self.delta = (float(dy), float(dz))

        self.possibleTargets = np.array(
            [(y, z) for y in self.y_grid for z in self.z_grid], dtype=float
        )

        self.all_covs: dict[str, np.ndarray] = {}
        for skill in self.candidate_execution_skills:
            key = self.get_key([skill, skill], r=0.0)
            self.all_covs[key] = self._covariance_from_skill(skill)

    # TODO: need to verify that this _covariance_from_skill method is what we actually want. The steps for determining
    #   which execution skill levels to test seem convoluted.

    @staticmethod
    def _covariance_from_skill(skill: float) -> np.ndarray:
        variance = 1.0 / max(skill, 1e-6) ** 2
        return np.diag([variance, variance])

    '''
    Examples of how skill translates to variance:
    skill: 0.25; variance: 16.000
    skill: 0.50; variance: 4.000
    skill: 0.75; variance: 1.778
    skill: 1.00; variance: 1.000
    skill: 1.25; variance: 0.640
    skill: 1.50; variance: 0.444
    skill: 1.75; variance: 0.327
    skill: 2.00; variance: 0.250
    '''

    @staticmethod
    def get_key(info: Sequence[float], r: float) -> str:
        return "|".join(map(str, info)) + f"|{r}"


@dataclass
class JEEDSInputs:
    spaces: SimpleHockeySpaces
    actions: list[list[float]]
    info_rows: list[dict[str, object]]


def _build_target_grids(df, grid_step: float) -> tuple[np.ndarray, np.ndarray]:
    # y_min, y_max = df["location_y"].min(), df["location_y"].max()
    # z_min, z_max = df["location_z"].min(), df["location_z"].max()

    # TODO: clean this up when done testing
    y_min, y_max = df["LOCATION_Y"].min(), df["LOCATION_Y"].max()
    z_min, z_max = df["LOCATION_Z"].min(), df["LOCATION_Z"].max()

    # Add a small buffer so the observed locations do not sit on the edge.
    pad = max(grid_step, 0.1)
    y_grid = np.arange(y_min - pad, y_max + pad + grid_step, grid_step)
    z_grid = np.arange(z_min - pad, z_max + pad + grid_step, grid_step)
    return y_grid, z_grid


def _ev_surface_for_shot(
    probability: float,
    location_y: float,
    location_z: float,
    y_grid: np.ndarray,
    z_grid: np.ndarray,
    base_sigma: float,
) -> np.ndarray:
    yy, zz = np.meshgrid(y_grid, z_grid, indexing="ij")
    dist2 = (yy - location_y) ** 2 + (zz - location_z) ** 2
    return probability * np.exp(-dist2 / (2.0 * base_sigma**2))


def transform_shots_for_jeeds(
    df,
    candidate_skills: Sequence[float],
    grid_step: float = 0.25,
    base_sigma: float = 0.5,
) -> JEEDSInputs:
    """Convert SQL rows into the structures JEEDS expects.

    Parameters
    ----------
    df:
        DataFrame returned by :func:`query_player_game_info`.
    candidate_skills:
        Execution-skill hypotheses passed to JEEDS.
    grid_step:
        Spacing (in rink meters) for the (y, z) grid used when constructing EV
        surfaces.
    base_sigma:
        Standard deviation (in rink meters) for the base Gaussian centered on
        the observed shot location.
    """

    y_grid, z_grid = _build_target_grids(df, grid_step)
    spaces = SimpleHockeySpaces(y_grid, z_grid, candidate_skills)

    info_rows: list[dict[str, object]] = []
    actions: list[list[float]] = []

    for _, row in df.iterrows():
        # TODO: clean up when done debugging
        # base_ev = _ev_surface_for_shot(
        #     probability=float(row["probability"]),
        #     location_y=float(row["location_y"]),
        #     location_z=float(row["location_z"]),
        #     y_grid=y_grid,
        #     z_grid=z_grid,
        #     base_sigma=base_sigma,
        # )

        base_ev = _ev_surface_for_shot(
            probability=float(row["PROBABILITY"]),
            location_y=float(row["LOCATION_Y"]),
            location_z=float(row["LOCATION_Z"]),
            y_grid=y_grid,
            z_grid=z_grid,
            base_sigma=base_sigma,
        )

        entry = {"evsPerXskill": {}, "maxEVPerXskill": {}, "focalActions": []}

        for skill in candidate_skills:
            key = spaces.get_key([skill, skill], r=0.0)
            # More skilled shooters keep reward mass near the aimed point; less
            # skilled shooters smear it out.
            sigma = max(grid_step / 3.0, base_sigma / max(math.sqrt(skill), 1e-3))
            evs = gaussian_filter(base_ev, sigma=sigma)

            entry["evsPerXskill"][key] = evs
            entry["maxEVPerXskill"][key] = float(np.max(evs))

            best_idx = int(np.argmax(evs))
            iy, iz = np.unravel_index(best_idx, (len(y_grid), len(z_grid)))
            entry["focalActions"].append([float(y_grid[iy]), float(z_grid[iz])])

        info_rows.append(entry)
        #TODO: clean up when done debugging
        # actions.append([float(row["location_y"]), float(row["location_z"])] )
        actions.append([float(row["LOCATION_Y"]), float(row["LOCATION_Z"])])

    return JEEDSInputs(spaces=spaces, actions=actions, info_rows=info_rows)


def ensure_results_directories(results_folder: Path) -> None:
    times_dir = results_folder / "times" / "estimators"
    times_dir.mkdir(parents=True, exist_ok=True)


def estimate_player_skill(
    player_id: int,
    game_ids: Sequence[int],
    *,
    candidate_skills: Sequence[float] | None = None,
    num_planning_skills: int = 25,
    grid_step: float = 0.25,
    base_sigma: float = 0.5,
    results_folder: Path | str = Path("blackhawks-jeeds"),
    rng_seed: int | None = 0,
) -> float:
    """Return the JEEDS MAP execution-skill estimate for a player.

    Parameters mirror :func:`transform_shots_for_jeeds` with additional JEEDS
    configuration knobs.  The estimator relies on the standard Blackhawks
    Snowflake environment variables to authenticate when fetching shots.
    """

    candidate_skills = list(candidate_skills or np.linspace(0.25, 2.0, 8))

    df = query_player_game_info(player_id=player_id, game_ids=list(game_ids))
    if df.empty:
        raise RuntimeError("No shot data returned for the requested player/games.")

    jeeds_inputs = transform_shots_for_jeeds(
        df,
        candidate_skills=candidate_skills,
        grid_step=grid_step,
        base_sigma=base_sigma,
    )

    estimator = JointMethodQRE(list(candidate_skills), num_planning_skills, "hockey-multi")
    results_folder = Path(results_folder)
    ensure_results_directories(results_folder)

    rng = np.random.default_rng(rng_seed)
    tag = f"Player_{player_id}"

    for idx, (info, action) in enumerate(zip(jeeds_inputs.info_rows, jeeds_inputs.actions)):
        estimator.add_observation(
            rng,
            jeeds_inputs.spaces,
            state=None,
            action=action,
            resultsFolder=str(results_folder),
            tag=tag,
            infoPerRow=info,
            s=str(idx),
        )

    results = estimator.get_results()
    map_key = f"{estimator.method_type}-MAP-{estimator.num_execution_skills}-{estimator.num_rationality_levels}-xSkills"
    estimates = results.get(map_key, [])
    if not estimates:
        raise RuntimeError("JEEDS returned no MAP execution-skill estimate.")

    return float(estimates[-1])


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run JEEDS on Blackhawks shots.")
    parser.add_argument("player_id", type=int, help="Hawks player identifier.")
    parser.add_argument(
        "game_ids",
        type=int,
        nargs="+",
        help="One or more game identifiers to include in the estimation run.",
    )
    # TODO: last exited recursive code check here

    parser.add_argument(
        "--candidate-skills",
        type=float,
        nargs="+",
        default=None,
        help="Optional execution-skill grid for JEEDS (defaults to 8 values between 0.25 and 2.0).",
    )

    # TODO: need to make sure that 0.25 up to 2.0 is a reasonable range for the data we are looking at;
    #  will need to check how .25 ... 2 are getting used; not sure whether they're raw rink meters or something else

    parser.add_argument(
        "--num-planning-skills",
        type=int,
        default=25,
        help="Number of planning-skill hypotheses passed to JEEDS.",
    )
    parser.add_argument(
        "--grid-step",
        type=float,
        default=0.25,
        help="Grid spacing (meters) for the reward surface.",
    )
    parser.add_argument(
        "--base-sigma",
        type=float,
        default=0.5,
        help="Base Gaussian sigma (meters) around the observed shot location.",
    )
    parser.add_argument(
        "--results-folder",
        type=Path,
        default=Path("Experiments/blackhawks-jeeds"),
        help="Directory where JEEDS timing hooks can write logs.",
    )
    parser.add_argument(
        "--rng-seed",
        type=int,
        default=0,
        help="Seed for the numpy random generator used during estimation.",
    )
    return parser.parse_args()


def main() -> None:
    args = _parse_args()
    estimate = estimate_player_skill(
        player_id=args.player_id,
        game_ids=args.game_ids,
        candidate_skills=args.candidate_skills,
        num_planning_skills=args.num_planning_skills,
        grid_step=args.grid_step,
        base_sigma=args.base_sigma,
        results_folder=args.results_folder,
        rng_seed=args.rng_seed,
    )
    print(f"JEEDS MAP execution skill: {estimate:.3f}")


if __name__ == "__main__":
    main()
